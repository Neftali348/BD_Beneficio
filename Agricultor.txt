-- 1. CREAR EL ESQUEMA "agricultor"
--CREATE SCHEMA IF NOT EXISTS agricultor;

-- 2. CREAR LAS TABLAS EN EL ESQUEMA "agricultor"

CREATE TABLE agricultor.agricultor (
    cui_agricultor VARCHAR(20) PRIMARY KEY,
    nit VARCHAR(20) UNIQUE,
    nombre VARCHAR(100) NOT NULL,
    observaciones TEXT,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    nombre_usuario VARCHAR(50) NOT NULL UNIQUE,
    password TEXT NOT NULL
);

CREATE TABLE agricultor.tipos_licencia (
    id_tipo_lic SERIAL PRIMARY KEY,
    tipo_licencia VARCHAR(50) NOT NULL UNIQUE
);

CREATE TABLE agricultor.tipo_medida (
    id_tipo_medida SERIAL PRIMARY KEY,
    tipo_medida VARCHAR(50) NOT NULL UNIQUE
);

CREATE TABLE agricultor.transportistas (
    cui VARCHAR(20) PRIMARY KEY,
    licencia VARCHAR(20) NOT NULL UNIQUE,
    nombre VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    fecha_venc_lic DATE NOT NULL,
    disponible BOOLEAN DEFAULT TRUE,
    empresa VARCHAR(100),
    observaciones TEXT,
    tipo_licencia INT NOT NULL,
    agricultor VARCHAR(20) NOT NULL,
    estado BOOLEAN DEFAULT TRUE,
    CONSTRAINT fk_tipo_licencia FOREIGN KEY (tipo_licencia) REFERENCES agricultor.tipos_licencia(id_tipo_lic) ON DELETE RESTRICT,
    CONSTRAINT fk_agricultor FOREIGN KEY (agricultor) REFERENCES agricultor.agricultor(cui_agricultor) ON DELETE CASCADE
);

CREATE TABLE agricultor.transportes (
    placa VARCHAR(20) PRIMARY KEY,
    marca VARCHAR(50) NOT NULL,
    color VARCHAR(30),
    linea VARCHAR(50),
    modelo VARCHAR(30),
    disponible BOOLEAN DEFAULT TRUE,
    estado BOOLEAN DEFAULT TRUE,
    agricultor VARCHAR(20) NOT NULL,
    CONSTRAINT fk_agricultor_transporte FOREIGN KEY (agricultor) REFERENCES agricultor.agricultor(cui_agricultor) ON DELETE CASCADE
);

CREATE TABLE agricultor.pesajes (
    id_pesaje SERIAL PRIMARY KEY,
    peso_total DECIMAL(10,2) NOT NULL,
    cant_parcialidades INT NOT NULL,
    medida_peso INT NOT NULL,
    fecha_envio TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    dif_total DECIMAL(10,2),
    no_cuenta VARCHAR(50),
    cui_agricultor VARCHAR(20) NOT NULL,
    CONSTRAINT fk_tipo_medida_pesaje FOREIGN KEY (medida_peso) REFERENCES agricultor.tipo_medida(id_tipo_medida) ON DELETE RESTRICT,
    CONSTRAINT fk_agricultor_pesaje FOREIGN KEY (cui_agricultor) REFERENCES agricultor.agricultor(cui_agricultor) ON DELETE CASCADE
);

CREATE TABLE agricultor.parcialidades (
    id_parcialidad SERIAL PRIMARY KEY,
    cui_transportista VARCHAR(20) NOT NULL,
    id_pesaje INT NOT NULL,
    placa VARCHAR(20) NOT NULL,
    tipo_medida INT NOT NULL,
    peso DECIMAL(10,2) NOT NULL,
    fecha_recepcion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_transportista FOREIGN KEY (cui_transportista) REFERENCES agricultor.transportistas(cui) ON DELETE CASCADE,
    CONSTRAINT fk_pesaje FOREIGN KEY (id_pesaje) REFERENCES agricultor.pesajes(id_pesaje) ON DELETE CASCADE,
    CONSTRAINT fk_transporte FOREIGN KEY (placa) REFERENCES agricultor.transportes(placa) ON DELETE CASCADE,
    CONSTRAINT fk_tipo_medida_parcialidad FOREIGN KEY (tipo_medida) REFERENCES agricultor.tipo_medida(id_tipo_medida) ON DELETE RESTRICT
);

CREATE TABLE agricultor.bitacora (
    id SERIAL PRIMARY KEY,
    tabla_afectada TEXT NOT NULL,
    id_registro_afectado TEXT NOT NULL,  
    campo_afectado TEXT NOT NULL,
    valor_actual TEXT NOT NULL,  
    accion CHAR(1) NOT NULL CHECK (accion IN ('I', 'U', 'D')),
    fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    usuario TEXT NOT NULL
);

CREATE TABLE agricultor.bitacora_detalle (
    id SERIAL PRIMARY KEY,
    id_bitacora INTEGER NOT NULL,
    valor_anterior TEXT,
    valor_nuevo TEXT,
    fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    usuario TEXT NOT NULL,
    FOREIGN KEY (id_bitacora) REFERENCES agricultor.bitacora(id) ON DELETE CASCADE
);

-- 3. CREAR LAS FUNCIONES DE BITÁCORA

CREATE OR REPLACE FUNCTION agricultor.registrar_bitacora_insert()
RETURNS TRIGGER AS $$
DECLARE
    v_usuario TEXT := CURRENT_USER;
    v_id_registro TEXT;
BEGIN
    v_id_registro := NEW.*::TEXT;

    INSERT INTO agricultor.bitacora (tabla_afectada, id_registro_afectado, campo_afectado, valor_actual, accion, usuario)
    VALUES (TG_TABLE_NAME, v_id_registro, 'Todos', row_to_json(NEW)::TEXT, 'I', v_usuario);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION agricultor.registrar_bitacora_update()
RETURNS TRIGGER AS $$
DECLARE
    v_usuario TEXT := CURRENT_USER;
    v_id_registro TEXT;
    v_campo TEXT;
    v_valor_anterior TEXT;
    v_valor_nuevo TEXT;
    v_bitacora_id INTEGER;
BEGIN
    v_id_registro := OLD.*::TEXT;

    FOR v_campo IN 
        SELECT column_name FROM information_schema.columns 
        WHERE table_name = TG_TABLE_NAME
    LOOP
        EXECUTE format('SELECT ($1).%I, ($2).%I', v_campo, v_campo) 
        INTO v_valor_anterior, v_valor_nuevo 
        USING OLD, NEW;

        IF v_valor_anterior IS DISTINCT FROM v_valor_nuevo THEN
            INSERT INTO agricultor.bitacora (tabla_afectada, id_registro_afectado, campo_afectado, valor_actual, accion, usuario)
            VALUES (TG_TABLE_NAME, v_id_registro, v_campo, v_valor_nuevo, 'U', v_usuario)
            RETURNING id INTO v_bitacora_id;

            INSERT INTO agricultor.bitacora_detalle (id_bitacora, valor_anterior, valor_nuevo, usuario)
            VALUES (v_bitacora_id, v_valor_anterior, v_valor_nuevo, v_usuario);
        END IF;
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 4. CREAR LOS TRIGGERS PARA TODAS LAS TABLAS DEL ESQUEMA

DO $$ 
DECLARE 
    r RECORD;
    sql_query TEXT;
BEGIN
    FOR r IN (
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'agricultor' 
        AND table_type = 'BASE TABLE'
        AND table_name NOT IN ('bitacora', 'bitacora_detalle')
    ) 
    LOOP
        sql_query := format('
            CREATE TRIGGER tr_insert_%I
            AFTER INSERT ON agricultor.%I
            FOR EACH ROW
            EXECUTE FUNCTION agricultor.registrar_bitacora_insert();', r.table_name, r.table_name);
        EXECUTE sql_query;

        sql_query := format('
            CREATE TRIGGER tr_update_%I
            AFTER UPDATE ON agricultor.%I
            FOR EACH ROW
            EXECUTE FUNCTION agricultor.registrar_bitacora_update();', r.table_name, r.table_name);
        EXECUTE sql_query;
    END LOOP;
END $$;

-- 5. INSERTAR DATOS INICIALES
INSERT INTO agricultor.agricultor (cui_agricultor, nit, nombre, observaciones, nombre_usuario, password) 
VALUES ('5234567890101', '52345678', 'Agricultor 1', 'Productor de café', 'agricultor1', 'password123');